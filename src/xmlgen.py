#! /usr/bin/env python
""" 
 Generate the XML file from the YAML file.
 The yaml file has a 'config' entry. This in turn contains a list of entries
 that represent various groups of sensors. For each group, there is a list of
 sensors and possibly a list of devices. If there are devices, then
 the sensors are repeated for each device.
 """

from math import ceil
import xml.etree.ElementTree as ET
import argparse
import os
import pprint
from typing import IO, Any, Tuple, List
import yaml

import utils # local import

# CONSTANTS
ZM_NUM_ENTRIES = 1024
C_OUTPUT_FILE = "ZynqMon_addresses.c"
C_OUTPUT_HEADER = "ZynqMon_addresses.h"

def sensor_size(thedict: dict) -> int:
    """calculate the size of the sensor in bytes"""
    sz = 2 # default size
    if '32' in thedict['type']:
        sz = 4
    elif 'char' in thedict['type']:
        sz = 1*thedict['char_count'] # 1 for char type
    return sz

def type_to_format(thedict: dict) -> str:
    """calculate the format of the sensor"""
    if 'uint' in thedict['type']: # uint16, uint32, uint8
        fmt = "u"
    elif 'int' in thedict['type']: # int16, int32, int8
        fmt = "d"
    elif thedict['type'] == 'fp16':
        fmt = "fp16"
    elif thedict['type'] == 'char':
        fmt = "c"
    else:
        print("ERROR: unknown type", thedict['type'])
        return None
    return fmt

def open_C_file(fname: str, header_fname: str) -> IO[Any]:
    """open the C file and write the header"""
    fout = open(fname, 'w', encoding='ascii')
    print(r"// This file is generated by mcu_generate.py", file=fout)
    print(r"// Do not edit this file directly", file=fout)
    print(r"// Edit the yaml files in the data directory and run mcu_generate.py", file=fout)
    print(r"// to generate this file", file=fout)
    print(r"//", file=fout)
    print(r"// This file contains the addresses of the zynqmon data", file=fout)
    print(r"// and the C calls to initialize the zynqmon data", file=fout)
    print(r"//", file=fout)
    print("#include \"Tasks.h\"", file=fout)
    # include the header file we will write later
    print(f"#include \"{header_fname}\"", file=fout)
    return fout

def write_C_header(header_fname: str, ZMON_VALID_ENTRIES: List[int]) -> None:
    """write the header file"""
    with open(header_fname, encoding="ascii", mode='w') as fheader:
        print(r"// This file is generated by mcu_generate.py", file=fheader)
        print(r"// Do not edit this file directly", file=fheader)
        print(r"// Edit the yaml files in the data directory and run mcu_generate.py", file=fheader)
        print(r"// to generate this file", file=fheader)
        print(r"//", file=fheader)
        print("#ifndef ZYNQMON_ADDRESSES_H", file=fheader)
        print("#define ZYNQMON_ADDRESSES_H", file=fheader)
        print("#ifdef REV1", file=fheader)
        print(f"#define ZMON_VALID_ENTRIES {ZMON_VALID_ENTRIES[0]}", file=fheader)
        print("#elif defined(REV2)", file=fheader)
        print(f"#define ZMON_VALID_ENTRIES {ZMON_VALID_ENTRIES[1]}", file=fheader)
        print("#endif // REV1", file=fheader)
        print("#endif // ZYNQMON_ADDRESSES_H", file=fheader)


def write_C_call(fout: IO[Any], c: dict, size: int) -> Tuple[int, int]:
    """write the C call to generate the filling of the data structures """
    if c['mcu_extra_call'] is None:
        print(f"zm_set_{c['mcu_call']}(&zynqmon_data[{size}], {c['start']});", file=fout)
    else :
        print(f"zm_set_{c['mcu_call']}(&zynqmon_data[{size}], {c['start']}, "
        f"{c['mcu_extra_call']});", file=fout)
    return (c['start'], c['start'] + int(c['count'])-1)


def make_node(parent: ET.Element, myid: str, thedict: dict, address: int) -> ET.Element:
    """create the node to be inserted into the xml tree"""
    thenode = ET.SubElement(parent, 'node')
    myid = myid.replace(' ', '_')
    thenode.set('id', myid)
    halfaddr = int(address/2)
    thenode.set('address', str(hex(halfaddr)))
    thenode.set("permission", "r")
    width = sensor_size(thedict)*8 # size in bits
    theformat = type_to_format(thedict) # format of the sensor
    thenode.set('format', theformat)

    # char type sensors are handled differently
    if thedict['type'] == 'char':
        thenode.set('mode', "incremental")
        val = int(ceil(thedict['char_count']/4.)) # 4 chars per 32 bit word here
        print(f"char_count: {thedict['char_count']}, val: {val}")
        thenode.set('size', str(hex(val)))
    else: # all other types have masks
        # the masks here will be either 32 or 16 bits
        mask = (1 << width) - 1
        is_odd = address % 2 == 1
        if not is_odd :
            thenode.set('mask', "0x{0:08X}".format(mask))
        else:
            thenode.set('mask', "0x{0:08X}".format(mask << 16))
    if 'extra' in thedict:
        extra = thedict['extra']
        if not "Column" in extra:
            extra = extra + ";Column=" + myid
        if not "Row" in extra:
            extra = extra + ";Row=" + myid
        thenode.set('extra', extra)
    return thenode

def main():
    """main function"""
    parser = argparse.ArgumentParser(description='Process YAML for XML.')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='increase output verbosity')
    parser.add_argument('-d', '--directory', type=str, help='output directory',
                        default='.')
    # this argument is required, one input file ending with yaml extension
    parser.add_argument('input_file', metavar='file', type=utils.yaml_file,
                        help='input yaml file name')

    args = parser.parse_args()

    if args.verbose:
        print('Verbose mode on')
        print('Input file names:', args.input_file)
        if args.directory:
            print('Output directory:', args.directory)

    # load YAML input file into memory
    with open(args.input_file, encoding='ascii') as f:
        y = yaml.load(f, Loader=yaml.FullLoader)

    # open C output file for writing
    c_fout = open_C_file(args.directory + '/' + C_OUTPUT_FILE, C_OUTPUT_HEADER)

    # start XML tree. This is the parent(root) tag onto which other tags will be
    # created
    cm = ET.Element('node')
    cm.set('id', 'CM')
    cm.set('address', '0x00000000')

    pprinter = pprint.PrettyPrinter(indent=4)

    # start processing the yaml file
    config = y['config']
    sensor_count = 0 # in 16 bit words
    summary = []
    categories = []
    for c in config:  # loop over entries in configuration (sensor category)
        if args.verbose:
            print("category:",)
            pprinter.pprint(c)
        # if there are several devices in the category, handle the case by iterating over them
        devices = c.get('devices', [])
        device_size = max(len(devices), 1)
        category_size = device_size*len(c['sensors'])*sensor_size(c)
        device = devices.pop(0) if devices else ""

        if args.verbose:
            print("category_size:", category_size)

        # write the C call to generate the filling of the data structures
        write_C_call(c_fout, c, sensor_count)

        while True:
            # if there are devices
            if device:
                pp = ET.SubElement(cm, 'node')
                pp.set('id', device)
            else:
                pp = cm
            for sensor in c['sensors']:
                if args.verbose:
                    print(f"sensor: {device}.{sensor}")
                make_node(pp, sensor, c, sensor_count)
                sensor_count += sensor_size(c) // 2
                summary.append((device + "." + sensor if device != "" else sensor, sensor_count))
            if devices:
                device = devices.pop(0)
            else:
                break
    tree = ET.ElementTree(cm)
    ET.indent(tree, space='\t')
    # create output file name based on input file, replacing 'yml' with 'xml'
    out_name = os.path.basename(args.input_file)[:-len('.yml')] + '.xml'
    out_name = args.directory + '/' + out_name
    if args.verbose:
        print("writing to file", out_name)
    tree.write(out_name)
    # write header file
    write_C_header(args.directory + '/' + C_OUTPUT_HEADER, [sensor_count, sensor_count])
    pprinter.pprint(summary)


if __name__ == "__main__":
    main()
